<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Mind Drops - ssh</title><link href="https://dmitry.khlebnikov.net/" rel="alternate"></link><link href="https://dmitry.khlebnikov.net/feeds/ssh.atom.xml" rel="self"></link><id>https://dmitry.khlebnikov.net/</id><updated>2020-05-17T20:25:15+10:00</updated><entry><title>Transparent SSH host-jumping (Expert)</title><link href="https://dmitry.khlebnikov.net/2016/07/26/transparent-ssh-host-jumping-expert/" rel="alternate"></link><published>2016-07-26T10:00:00+10:00</published><updated>2020-05-17T04:45:11+10:00</updated><author><name>(GalaxyMaster)</name></author><id>tag:dmitry.khlebnikov.net,2016-07-26:/2016/07/26/transparent-ssh-host-jumping-expert/</id><summary type="html">&lt;p&gt;A while ago in the &lt;a href="https://dmitry.khlebnikov.net/2015/08/06/transparent-ssh-host-jumping-advanced/"&gt;Transparent SSH host-jumping (Advanced)&lt;/a&gt; post I
described a technique on how one could jump quite effortlessly through a chain
of intermediate hosts. However, there was a catch: the user names and ports
across the whole chain should be the same and there was no easy way to change
that.&lt;/p&gt;
&lt;p&gt;Given that I &lt;a href="https://dmitry.khlebnikov.net/2016/07/25/ssh-interactive-proxycommand/"&gt;recently&lt;/a&gt; paid quite a lot of attention to the ProxyCommand
directive I decided to look into the implementation of the helper script that
will allow one to tweak parameters for the hosts in the chain.&lt;/p&gt;
&lt;p&gt;You can read the &lt;a href="https://dmitry.khlebnikov.net/2015/08/06/transparent-ssh-host-jumping-advanced/"&gt;original&lt;/a&gt; post for the &lt;span class="truncated"&gt;&lt;/span&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;A while ago in the &lt;a href="https://dmitry.khlebnikov.net/2015/08/06/transparent-ssh-host-jumping-advanced/"&gt;Transparent SSH host-jumping (Advanced)&lt;/a&gt; post I
described a technique on how one could jump quite effortlessly through a chain
of intermediate hosts. However, there was a catch: the user names and ports
across the whole chain should be the same and there was no easy way to change
that.&lt;/p&gt;
&lt;p&gt;Given that I &lt;a href="https://dmitry.khlebnikov.net/2016/07/25/ssh-interactive-proxycommand/"&gt;recently&lt;/a&gt; paid quite a lot of attention to the ProxyCommand
directive I decided to look into the implementation of the helper script that
will allow one to tweak parameters for the hosts in the chain.&lt;/p&gt;
&lt;p&gt;You can read the &lt;a href="https://dmitry.khlebnikov.net/2015/08/06/transparent-ssh-host-jumping-advanced/"&gt;original&lt;/a&gt; post for the details of how this host-jumping
technique works, here I am only going to provide the proxy script and the
corresponding ssh config parameter block to use the script.&lt;/p&gt;
&lt;p&gt;The goal was to support the following syntax:&lt;/p&gt;
&lt;pre class="highlight" data-user="user"&gt;&lt;code class="language-shell"&gt;[user@localhost ~]$ ssh default_user@userA^hostA/userB^hostB:port/hostC&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It was a little challenge to come up with the character for identifying the
user part for intermediate hosts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@&lt;/code&gt; - cannot be used since SSH parses the command line before providing the
    string to the ProxyCommand script&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt; - cannot be used since SSH was thinking that I&amp;rsquo;m trying to do an
    expansion of the internal SSH variable&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;)&lt;/code&gt;, and &lt;code&gt;&amp;amp;&lt;/code&gt; - are all shell unfriendly&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So I decided on the &lt;code&gt;^&lt;/code&gt; character as a delimiter.&lt;/p&gt;
&lt;p&gt;In the proposed command above the &amp;ldquo;default_user&amp;rdquo; is the user name we ultimately
want to use for logging into the last host in the chain (it happens that this
user name will be used for any host in the chain where no alternative name is
provided).&lt;/p&gt;
&lt;p&gt;Each host in the chain could also be provided with the relevant port or, if the
port is omitted, it will use the global port configuration (usually 22/tcp but
can be changed with the &lt;code&gt;-p&lt;/code&gt; argument to ssh).  The script is a bit not optimised
(bash is really slow on string processing, but I decided to stick with pure
bash where it was possible):&lt;/p&gt;
&lt;pre class="highlight" data-file="~/bin/ssh-helper.sh"&gt;&lt;code class="language-bash"&gt;#!/bin/bash
set -eu -o pipefail
exec 10&amp;lt;&amp;amp;0 11&amp;gt;&amp;amp;1 0&amp;lt;&amp;amp;2 1&amp;gt;&amp;amp;2
DEFAULT_USER=&amp;quot;$1&amp;quot;
DEFAULT_PORT=&amp;quot;$3&amp;quot;
HOST_CHAIN=&amp;quot;$2&amp;quot;
HOST_NEXT=&amp;quot;${HOST_CHAIN%%/*}&amp;quot;
HOST_USER=&amp;quot;${HOST_NEXT%%^*}&amp;quot;
[ &amp;quot;$HOST_USER&amp;quot; == &amp;quot;$HOST_NEXT&amp;quot; ] &amp;amp;&amp;amp; HOST_USER=&amp;quot;$DEFAULT_USER&amp;quot; ||:
HOST_PORT=&amp;quot;${HOST_NEXT##*:}&amp;quot;
[ &amp;quot;$HOST_PORT&amp;quot; == &amp;quot;$HOST_NEXT&amp;quot; ] &amp;amp;&amp;amp; HOST_PORT=&amp;quot;$DEFAULT_PORT&amp;quot; ||:
TARGET_HOST=&amp;quot;${HOST_CHAIN##*/}&amp;quot;
TARGET_PORT=&amp;quot;${TARGET_HOST##*:}&amp;quot;
TARGET_HOST=&amp;quot;${TARGET_HOST%:*}&amp;quot;
[ &amp;quot;$TARGET_PORT&amp;quot; == &amp;quot;$TARGET_HOST&amp;quot; ] &amp;amp;&amp;amp; TARGET_PORT=&amp;quot;$DEFAULT_PORT&amp;quot; ||:
TARGET_HOST=&amp;quot;${TARGET_HOST#*^}&amp;quot;
HOST_NEXT=&amp;quot;${HOST_NEXT#*^}&amp;quot;
HOST_NEXT=&amp;quot;${HOST_NEXT%:*}&amp;quot;
HOST_CHAIN=&amp;quot;${HOST_CHAIN%/*}&amp;quot;
[ &amp;quot;$HOST_CHAIN&amp;quot; == &amp;quot;${HOST_CHAIN#*/}&amp;quot; ] &amp;amp;&amp;amp; HOST_CHAIN= || HOST_CHAIN=&amp;quot;${HOST_CHAIN#*/}&amp;quot;
HOST_CHAIN=&amp;quot;$HOST_NEXT${HOST_CHAIN:+/$HOST_CHAIN}&amp;quot;

if [ ! -d &amp;quot;$HOME/.ssh/.sessions&amp;quot; ]; then
    echo &amp;quot;Creating the sessions directory&amp;quot; &amp;gt;&amp;amp;2
    mkdir -m700 &amp;quot;$HOME/.ssh/.sessions&amp;quot;
fi

CONTROL_SOCKET=$(printf &amp;quot;$HOST_USER@HOST_CHAIN:$HOST_PORT\n&amp;quot; | shasum | cut -f1 -d' ')

exec 0&amp;lt;&amp;amp;10 1&amp;gt;&amp;amp;11
exec ssh \
    -o &amp;quot;ControlMaster auto&amp;quot; \
    -o &amp;quot;ControlPath ~/.ssh/.sessions/$CONTROL_SOCKET&amp;quot; \
    -o &amp;quot;ControlPersist 120s&amp;quot; \
    -l &amp;quot;$HOST_USER&amp;quot; \
    -p &amp;quot;$HOST_PORT&amp;quot; \
    &amp;quot;$HOST_CHAIN&amp;quot; \
    -W &amp;quot;$TARGET_HOST&amp;quot;:&amp;quot;$TARGET_PORT&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above is a proof of the concept and it &amp;ldquo;works for me&amp;rdquo; :). I am using it
every day when I need to access boxes behind a bastion host. Your mileage may
vary and you are free to create your own version of the script that would
perform better (I would be really glad if a version of such a script could be
shared with me).&lt;/p&gt;
&lt;p&gt;The corresponding configuration block in the ssh config file looks as follows:&lt;/p&gt;
&lt;pre class="highlight" data-file="~/.ssh/config"&gt;&lt;code class="language-ssh_config"&gt;Host */*
    # if you uncomment ControlPath you also need to uncomment ControlMaster
    #ControlMaster auto
    # For OpenSSH &amp;lt; 6.7 you may uncomment the following, but long chains will fail:
    #ControlPath   ~/.ssh/.sessions/%r@%h:%p
    # For OpenSSH &amp;gt;= 6.7 you should uncomment the following:
    #ControlPath   ~/.ssh/.sessions/%C
    ProxyCommand ~/bin/ssh-helper.sh %r %h %p&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, this is a bit messy since OpenSSH introduced the &lt;code&gt;%C&lt;/code&gt; macro in version 6.7
and without &lt;code&gt;%C&lt;/code&gt; the &lt;code&gt;ControlPath&lt;/code&gt; string gets too long for OpenSSH to create a
socket on the filesystem for long chains of hosts.&lt;/p&gt;</content><category term="ssh"></category><category term="console"></category><category term="ssh"></category><category term="howto"></category></entry><entry><title>SSH: Interactive ProxyCommand</title><link href="https://dmitry.khlebnikov.net/2016/07/25/ssh-interactive-proxycommand/" rel="alternate"></link><published>2016-07-25T10:00:00+10:00</published><updated>2020-05-17T04:45:11+10:00</updated><author><name>(GalaxyMaster)</name></author><id>tag:dmitry.khlebnikov.net,2016-07-25:/2016/07/25/ssh-interactive-proxycommand/</id><summary type="html">&lt;p&gt;I was involved in the creation of the &lt;a href="https://github.com/realestate-com-au/sshephalopod"&gt;sshephalopod&lt;/a&gt; project, which was an
attempt to build an enterprise level authentication framework for SSH
authentication using the SSH &lt;abbr title="Certificate Authority"&gt;CA&lt;/abbr&gt; feature.&lt;/p&gt;
&lt;p&gt;The project is based on a wrapper script that signs a user via a &lt;abbr title="Security Assertion Markup Language"&gt;SAML&lt;/abbr&gt; identity
provider and gets user&amp;rsquo;s public key signed for the further usage.&lt;/p&gt;
&lt;p&gt;In one of the discussions I pointed out that such a wrapper script is not good
for the end user experience and I proposed to provide the users with an excerpt
for their ssh config file, so the functionality of sshephalopod would be &lt;span class="truncated"&gt;&lt;/span&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;I was involved in the creation of the &lt;a href="https://github.com/realestate-com-au/sshephalopod"&gt;sshephalopod&lt;/a&gt; project, which was an
attempt to build an enterprise level authentication framework for SSH
authentication using the SSH &lt;abbr title="Certificate Authority"&gt;CA&lt;/abbr&gt; feature.&lt;/p&gt;
&lt;p&gt;The project is based on a wrapper script that signs a user via a &lt;abbr title="Security Assertion Markup Language"&gt;SAML&lt;/abbr&gt; identity
provider and gets user&amp;rsquo;s public key signed for the further usage.&lt;/p&gt;
&lt;p&gt;In one of the discussions I pointed out that such a wrapper script is not good
for the end user experience and I proposed to provide the users with an excerpt
for their ssh config file, so the functionality of sshephalopod would be
transparent to the general usage scenario of the ssh tool.&lt;/p&gt;
&lt;p&gt;The response was that ProxyCommand do not support interactivity. Well, as they
say: The challenge is accepted :)&lt;/p&gt;
&lt;p&gt;The following is my train of thoughts before I came up with a general solution
on how to allow an interactive command to be used as the ProxyCommand in the
ssh config file.&lt;/p&gt;
&lt;p&gt;Before we start solving the problem at hand we need to create a test
environment, so we would be able to confirm when we reached success. The task
itself was very simple: we needed a host we could ssh into (an sshd daemon
running on the local host would be sufficient), then we needed an interactive
script, and a configuration block for the connection.&lt;/p&gt;
&lt;p&gt;The configuration block is pretty simple (%h expands to localhost and %p
expands to the port specified on the command line or to &amp;ldquo;22&amp;rdquo; otherwise):&lt;/p&gt;
&lt;pre class="highlight" data-user="user"&gt;&lt;code class="language-shell"&gt;[user@localhost ~]$ fgrep -A1 'Host localhost' ~/.ssh/config
Host localhost
 ProxyCommand ~/bin/interactive.script.sh %h %p&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since most of our research is going to be inside the interactive script you
will see several incarnations of script&amp;rsquo;s body. The very first one was the
following:&lt;/p&gt;
&lt;pre class="highlight" data-file="~/bin/interactive.script.sh"&gt;&lt;code class="language-bash"&gt;#!/bin/bash
exec nc &amp;quot;$1&amp;quot; &amp;quot;$2&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point we just need to confirm that our test environment works as
expected &amp;ndash; the ssh session should be proxied through the nc command and we
should be able to login under our own account via ssh to the localhost (my
private key was added to the key manager with ssh-add, hence no password prompt
was displayed):&lt;/p&gt;
&lt;pre class="highlight" data-user="user"&gt;&lt;code class="language-shell"&gt;[user@localhost ~]$ ssh galaxy@localhost
Last login: Thu Jul 21 01:30:21 2016
$&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, we confirmed that we can establish a proxied connection and tunnel our ssh
session through it.&lt;/p&gt;
&lt;p&gt;Each interactive script or program relies on the communication channel with the
user otherwise it could not be interactive. This channel comprises at least of
two file descriptors: one for standard input and the other for standard output,
so let&amp;rsquo;s check what descriptors are available for our script:&lt;/p&gt;
&lt;pre class="highlight" data="file="~/bin/interactive.script.sh""&gt;&lt;code class="language-bash"&gt;#!/bin/bash
# on Linux the following line would be much simpler: ls -l /proc/$$/fd/, but
# on OS X they do not expose the open file descriptors through /proc, so I
# used &amp;quot;lsof&amp;quot; instead.
lsof -p $$ &amp;gt;&amp;amp;2
exec nc &amp;quot;$1&amp;quot; &amp;quot;$2&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we try to connect now we should see something like the following (I am
writing this article on an OS X machine so I provide the output from OS X,
however this also works for Linux):&lt;/p&gt;
&lt;pre class="highlight" data-user="user"&gt;&lt;code class="language-shell"&gt;[user@localhost ~]$ ssh galaxy@localhost
COMMAND   PID   USER   FD   TYPE             DEVICE  SIZE/OFF     NODE NAME
bash    45225   user  cwd    DIR                1,2       612   893854 /Users/user/.ssh
bash    45225   user  txt    REG                1,2    628640  2329236 /bin/bash
bash    45225   user  txt    REG                1,2    625712 13892061 /usr/lib/dyld
bash    45225   user  txt    REG                1,2 385393734 13894121 /private/var/run/dyld_shared_cache_x86_64
bash    45225   user    0   PIPE 0x44d71099589485df     16384          -&amp;gt;0x44d7109951223d0f
bash    45225   user    1   PIPE 0x44d710995122454f     16384          -&amp;gt;0x44d71099512246af
bash    45225   user    2u   CHR               16,1  0t631830     9705 /dev/ttys001
bash    45225   user  255r   REG                1,2       219 15455259 /Users/user/bin/interactive.script.sh
Last login: Mon Jul 25 17:52:40 2016 from localhost
$&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are interested in file descriptors 0 (standard input), 1 (standard output),
and 2 (standard error). As you can see the standard input and output are part
of the pipes (presumably linking them to the parent ssh process) and standard
error is pointing to our terminal session.&lt;/p&gt;
&lt;p&gt;I could have occupied a bit more of the page space showcasing that if you try
to communicate on standard input and/or output the ssh client will terminate
since you will be messing with the SSH protocol flow, but I believe you will
trust me on this :).&lt;/p&gt;
&lt;p&gt;What can we do to interact with the user, yet to preserve the channel with the
parent ssh process? Well, the answer is quite obvious:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;we have a pointer to the terminal session (file descriptor 2, the standard
    error, points to the terminal),&lt;/li&gt;
&lt;li&gt;so we just need to save pointers to the pipes&amp;rsquo; ends,&lt;/li&gt;
&lt;li&gt;re-open standard input and output with the terminal before we interact with
    the user,&lt;/li&gt;
&lt;li&gt;and restore these file descriptors back once we are ready to hand over the
    ssh session.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following version of the script demonstrates the implementation of the
above logic:&lt;/p&gt;
&lt;pre class="highlight" data-file="~/bin/interactive.script.sh"&gt;&lt;code class="language-bash"&gt;#!/bin/bash
exec 10&amp;lt;&amp;amp;0 11&amp;gt;&amp;amp;1 0&amp;lt;&amp;amp;2 1&amp;gt;&amp;amp;2
# start of the interactive behaviour
lsof -p $$
read -p &amp;quot;Type something: &amp;quot; I
echo &amp;quot;You typed: $I&amp;quot;
# finish of the interactive behaviour
exec 0&amp;lt;&amp;amp;10 1&amp;gt;&amp;amp;11
exec nc &amp;quot;$1&amp;quot; &amp;quot;$2&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think it is time to test it :) :&lt;/p&gt;
&lt;pre class="highlight" data-user="user"&gt;&lt;code class="language-shell"&gt;[user@localhost ~]$ ssh galaxy@localhost
COMMAND   PID   USER   FD   TYPE             DEVICE  SIZE/OFF     NODE NAME
bash    45238   user  cwd    DIR                1,2       612   893854 /Users/user/.ssh
bash    45238   user  txt    REG                1,2    628640  2329236 /bin/bash
bash    45238   user  txt    REG                1,2    625712 13892061 /usr/lib/dyld
bash    45238   user  txt    REG                1,2 385393734 13894121 /private/var/run/dyld_shared_cache_x86_64
bash    45238   user    0u   CHR               16,1  0t640407     9705 /dev/ttys001
bash    45238   user    1u   CHR               16,1  0t640407     9705 /dev/ttys001
bash    45238   user    2u   CHR               16,1  0t640407     9705 /dev/ttys001
bash    45238   user   10   PIPE 0x44d710995122378f     16384          -&amp;gt;0x44d71099589494ff
bash    45238   user   11   PIPE 0x44d7109951223d0f     16384          -&amp;gt;0x44d710995122454f
bash    45238   user  255r   REG                1,2       135 15455285 /Users/user/bin/interactive.script.sh
Type something: This is a test
You typed: This is a test
Last login: Mon Jul 25 17:57:05 2016 from localhost
$ logout
Connection to localhost closed.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mission accomplished! :)&lt;/p&gt;
&lt;p&gt;I hope this small article would help somebody to design better wrappers around
SSH. Keep in mind that you could always optimise it further. For example, recent
versions of OpenSSH support passing of a file descriptor from the ProxyCommand
script, so if you have a decent netcat tool that supports the &amp;ldquo;-F&amp;rdquo; option
(fdpass) you could get native performance for the ssh communication link with
no proxy process hanging around.&lt;/p&gt;
&lt;p&gt;P.S. if you have any questions do not hesitate to comment.&lt;/p&gt;</content><category term="ssh"></category><category term="ssh"></category><category term="console"></category></entry><entry><title>Transparent SSH host-jumping (Advanced)</title><link href="https://dmitry.khlebnikov.net/2015/08/06/transparent-ssh-host-jumping-advanced/" rel="alternate"></link><published>2015-08-06T10:00:00+10:00</published><updated>2020-05-17T20:25:15+10:00</updated><author><name>(GalaxyMaster)</name></author><id>tag:dmitry.khlebnikov.net,2015-08-06:/2015/08/06/transparent-ssh-host-jumping-advanced/</id><summary type="html">&lt;p&gt;In this brief article I am going to describe how I resolved a nagging issue I
had with setting up access to hosts which are not directly reachable, but where
you need to forward your connection through an intermediate host.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://dmitry.khlebnikov.net/2010/12/10/ssh-port-forwarding-intermediate/"&gt;Previously&lt;/a&gt;, I was using the local SSH port-forwarding technique (although I
was configuring hosts I connect to in the &lt;code&gt;~/.ssh/config&lt;/code&gt; file instead of
using the command-line options). However, this approach turned out to be quite
inconvenient since every time I wanted to connect to a new host (and, possibly,
through a new intermediate host) I had to edit my &lt;span class="truncated"&gt;&lt;/span&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this brief article I am going to describe how I resolved a nagging issue I
had with setting up access to hosts which are not directly reachable, but where
you need to forward your connection through an intermediate host.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://dmitry.khlebnikov.net/2010/12/10/ssh-port-forwarding-intermediate/"&gt;Previously&lt;/a&gt;, I was using the local SSH port-forwarding technique (although I
was configuring hosts I connect to in the &lt;code&gt;~/.ssh/config&lt;/code&gt; file instead of
using the command-line options). However, this approach turned out to be quite
inconvenient since every time I wanted to connect to a new host (and, possibly,
through a new intermediate host) I had to edit my SSH configuration file and
add something like the following:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-ssh_config"&gt;Host intermediate
    HostName 192.168.1.1
    HostKeyAlias intermediate
    LocalForward 10001 target:22

Host target
    HostName 127.0.0.1
    HostKeyAlias target
    Port 10001&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Upon closer examination of my day-to-day routine I found two things that
frustrated me the most:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;My &lt;code&gt;~/.ssh/config&lt;/code&gt; file was growing uncontrollably and became hard to
     navigate;&lt;/li&gt;
&lt;li&gt;Each time I needed to connect to the target host through the intermediate
     host I had to open two sessions with one of them being idle most of the
     time.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After a while I stumbled upon an article describing quite a generic way to
tunnel through an intermediate host and found the approach quite convenient for
the day-to-day use. So, I have added the following block into my &lt;code&gt;~/.ssh/config&lt;/code&gt;
file just before the &lt;code&gt;Host *&lt;/code&gt; section:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-ssh_config"&gt;Host */*
    ProxyCommand ssh $(dirname %h) -W $(basename %h):%p&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From that point on, I could connect to a target host via an intermediate one
by simply executing the following command:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-shell"&gt;ssh user@intemediate/target&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The configuration with the &lt;code&gt;ProxyCommand&lt;/code&gt; directive was spawning two &lt;code&gt;ssh&lt;/code&gt;
processes with one connected to the intermediate host in the background and the
other proxied through the intermediate host and connected to the target running
in the foreground, so from my point of view I had just one terminal session
open. The configuration allowed to chain as many hosts as I wanted, e.g.:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-shell"&gt;ssh user@hostA/hostB/hostC/hostD&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above would result in three &lt;code&gt;ssh&lt;/code&gt; processes running in the background (the
first connected to hostA, the second connected to &lt;em&gt;hostB&lt;/em&gt; proxied through &lt;em&gt;hostA&lt;/em&gt;,
and the third connected to &lt;em&gt;hostC&lt;/em&gt; proxied through &lt;em&gt;hostB&lt;/em&gt;) and one foreground
process which was connected to &lt;em&gt;hostD&lt;/em&gt; proxied via &lt;em&gt;hostC&lt;/em&gt;. This is great and quite
flexible to use, however, this approach has a number of limitations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;you cannot specify different ports for different hosts in a chain;&lt;/li&gt;
&lt;li&gt;neither can you use different login names for different hosts in the chain;&lt;/li&gt;
&lt;li&gt;establishing connection to different chains sharing a part of the chain
    would not reuse already established connections, i.e. slow connection times.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Personally, I am using the same login name and the same ports on hosts I am
accessing, so the first two items were not an issue for me, but the last one
was irritating enough and I decided to figure out whether it is possible to
optimise it. After a bit of reading the documentation and a few attempts I came
up with the following configuration block in my &lt;code&gt;~/.ssh/config&lt;/code&gt; file (remember,
this block should be placed &lt;em&gt;before&lt;/em&gt; the &lt;code&gt;Host *&lt;/code&gt; one):&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-ssh_config"&gt;Host */*
    ControlMaster auto
    ControlPath   ~/.ssh/.sessions/%r@%h:%p
    ProxyCommand /bin/sh -c 'mkdir -p -m700 ~/.ssh/.sessions/&amp;quot;%r@$(dirname %h)&amp;quot; &amp;amp;&amp;amp; exec ssh -o &amp;quot;ControlMaster auto&amp;quot; -o &amp;quot;ControlPath   ~/.ssh/.sessions/%r@$(dirname %h):%p&amp;quot; -o &amp;quot;ControlPersist 120s&amp;quot; -l %r -p %p $(dirname %h) -W $(basename %h):%p'&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s review it line by line, so the logic is clear:&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-ssh_config"&gt;Host */*&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This host definition block would catch any host specified on the &lt;code&gt;ssh&lt;/code&gt; command
line when the host name matches the &lt;code&gt;*/*&lt;/code&gt; pattern, so &lt;code&gt;ssh hostA/hostB/hostC&lt;/code&gt;
will be matched as &lt;code&gt;hostA/hostB&lt;/code&gt; being the first part before &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;hostC&lt;/code&gt; as
the second part after &lt;code&gt;/&lt;/code&gt;. Due to a recursive call to &lt;code&gt;ssh&lt;/code&gt; (see below) this
block will be recursively applied to all hosts in the specified chain.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-ssh_config"&gt;    ControlMaster auto&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This directive instructs &lt;code&gt;ssh&lt;/code&gt; to try to reuse an existing control channel to
communicate with the remote host, and if such a channel does not exist it will
be created, so further connections to the same remote host would benefit from
a speedup provided by the already established connection.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-ssh_config"&gt;    ControlPath ~/.ssh/.sessions/%r@%h:%p&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This directive provides &lt;code&gt;ssh&lt;/code&gt; with the location of the control channel socket
file. The socket file should be unique for each remote host. Since we are
reusing the existing connection and skipping the authentication the socket file
should be tagged with the corresponding login name, this is why we are using %r
(remote login name), %h (the remote host name), and %p (the remote port) as
part of the file name. Please note that due to our usage of &amp;ldquo;/&amp;rdquo; as a host
separator in the chain the path constructed here will have a subdirectory
defined in the middle of the %h expansion. &lt;code&gt;ssh&lt;/code&gt; would not automatically create
that subdirectory, so it is something we need to address (see below)&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-ssh_config"&gt;    ProxyCommand …&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the heart of the whole block. I am starting this proxy command with
&lt;code&gt;/bin/sh -c '…'&lt;/code&gt; since &lt;code&gt;ssh&lt;/code&gt; is &lt;code&gt;exec()&lt;/code&gt;uting the specified command (this
replaces the spawned shell and makes it impossible to conditionally chain
commands), therefore I am using the shell binary as the proxy command to get
the ability to script my logic. Then I am creating the required directory
structure for the control channels under &lt;code&gt;~/.ssh/.sessions&lt;/code&gt; (note the &lt;code&gt;-p&lt;/code&gt;
argument to &lt;code&gt;mkdir&lt;/code&gt;, this will create all the missing parts of the specified
tree, but also would silence &lt;code&gt;mkdir&lt;/code&gt; in case all of the directories already
exist). It is worth to mention that with this &lt;code&gt;mkdir&lt;/code&gt; command I am creating the
subdirectory for the &lt;code&gt;ControlPath&lt;/code&gt; defined for the enclosing &lt;code&gt;Host */*&lt;/code&gt; block.&lt;/p&gt;
&lt;p&gt;The second part of the command line is conditionally executing &lt;code&gt;ssh&lt;/code&gt; if &lt;code&gt;mkdir&lt;/code&gt;
did not report any issues. It is good to execute &lt;code&gt;ssh&lt;/code&gt; here since we do not
need a redundant shell hanging around in the process tree. In this recursive
&lt;code&gt;ssh&lt;/code&gt; call we explicitly specify that we also need multiplexing of the control
channels created by the parent connections (they are &amp;ldquo;parent&amp;rdquo; since this is the
connection that established first and which enables access to the hosts further
down the specified chain) as well as we explicitly specify the location of the
control channel (note that since it is a parrent connection we are stripping
the rest of host names from the &lt;code&gt;%h&lt;/code&gt; macro using &lt;code&gt;dirname&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Finally, the third explicitly specified directive is &lt;code&gt;ControlPersist&lt;/code&gt; which is
set to &lt;code&gt;120s&lt;/code&gt;. This directive instructs &lt;code&gt;ssh&lt;/code&gt; to stay in the background and
maintain the control channel in case we decide to reuse it, but if no activity
on the control channel is detected for 2 minutes the &lt;code&gt;ssh&lt;/code&gt; process would
terminate. Without this directive the moment you close the connection which was
the master connection all dependent connections would also be closed, e.g. if
you have two sessions: one to &lt;code&gt;hostA/hostB&lt;/code&gt; and the other to &lt;code&gt;hostA/hostC&lt;/code&gt;, the
moment you closed the first connection the second one will be immediately
terminated if you do not have the &lt;code&gt;ControlPersist&lt;/code&gt; configured.&lt;/p&gt;
&lt;p&gt;The rest of the &lt;code&gt;ssh&lt;/code&gt; arguments is obvious: we connect to the first host in the
provided host chain (we are extracting that part with &lt;code&gt;dirname %h&lt;/code&gt;) and we are
proxying stdin/stdout to the last host in the supplied chain with the &lt;code&gt;-W&lt;/code&gt;
option.&lt;/p&gt;
&lt;p&gt;Basically, the control flow when you do &lt;code&gt;ssh user@hostA/hostB/hostC&lt;/code&gt; is the
following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ssh&lt;/code&gt; matches the &lt;code&gt;*/*&lt;/code&gt; pattern against the provided host name
     (&lt;code&gt;hostA/hostB/hostC&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ssh&lt;/code&gt; tries to reuse the control channel by attempting to open the
     &lt;code&gt;~/.ssh/.sessions/user@hostA/hostB/hostC:22&lt;/code&gt; socket, if successful the
     connection is established and the command prompt is displayed to the
     calling user, otherwise the execution continues&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ssh&lt;/code&gt; executes the defined &lt;code&gt;ProxyCommand&lt;/code&gt; command&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the first part of the command creates &lt;code&gt;~/.ssh/.sessions/hostA/hostB&lt;/code&gt; if it
     is not there&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the second part executes&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="language-shell"&gt;ssh … -o &amp;quot;ControlPath ~/.ssh/.sessions/user@hostA/hostB:22&amp;quot; … hostA/hostB -W hostC:22&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will initiate another round of the above steps, but with a shorter chain
 and it will be recursive until there is just a single host left, e.g. when
 we ascend to &lt;code&gt;hostA&lt;/code&gt; as the host to connect to.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;now, with connected stdin/stdout to port 22 on &lt;code&gt;hostC&lt;/code&gt; (in the last
     iteration) &lt;code&gt;ssh&lt;/code&gt; performs the authentication against &lt;code&gt;hostC&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if authentication is successful &lt;code&gt;ssh&lt;/code&gt; creates the
     &lt;code&gt;~/.ssh/.sessions/user@hostA/hostB/hostC:22&lt;/code&gt; control channel socket and
     becomes the master of that control channel&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a command prompt is displayed to the calling user&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I hope this little trick will save you some time and will make your life
easier. :)&lt;/p&gt;</content><category term="ssh"></category><category term="console"></category><category term="ssh"></category><category term="howto"></category></entry><entry><title>SSH port-forwarding (Intermediate)</title><link href="https://dmitry.khlebnikov.net/2010/12/10/ssh-port-forwarding-intermediate/" rel="alternate"></link><published>2010-12-10T10:00:00+11:00</published><updated>2020-05-17T04:45:11+10:00</updated><author><name>(GalaxyMaster)</name></author><id>tag:dmitry.khlebnikov.net,2010-12-10:/2010/12/10/ssh-port-forwarding-intermediate/</id><summary type="html">&lt;p&gt;In my previous blog entry I described some basic functionality of SSH in terms
of port-forwarding. Now it&amp;rsquo;s time for a little bit more complex stuff.&lt;/p&gt;
&lt;p&gt;In this article I will highlight:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(forward) piercing of a firewall (getting access to resources behind it);&lt;/li&gt;
&lt;li&gt;dynamic port-forwarding (AKA proxy);&lt;/li&gt;
&lt;li&gt;(reverse) piercing of a firewall (exposing your local services on the remote side).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="forward-firewall-piercing"&gt;Forward firewall piercing&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s start with the forward firewall piercing, since it is the easiest and was
somewhat already described in my previous blog entry on this topic. Now,
imagine that you already have SSH access to some &lt;span class="truncated"&gt;&lt;/span&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;In my previous blog entry I described some basic functionality of SSH in terms
of port-forwarding. Now it&amp;rsquo;s time for a little bit more complex stuff.&lt;/p&gt;
&lt;p&gt;In this article I will highlight:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(forward) piercing of a firewall (getting access to resources behind it);&lt;/li&gt;
&lt;li&gt;dynamic port-forwarding (AKA proxy);&lt;/li&gt;
&lt;li&gt;(reverse) piercing of a firewall (exposing your local services on the remote side).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="forward-firewall-piercing"&gt;Forward firewall piercing&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s start with the forward firewall piercing, since it is the easiest and was
somewhat already described in my previous blog entry on this topic. Now,
imagine that you already have SSH access to some host which is multi-home
connected (e.g. the host is connected to more than one network). Let&amp;rsquo;s also
assume that the host is a firewall and is masquerading other hosts in the
internal network and is translating just a handful set of ports to the servers
(looks familiar, doesn&amp;rsquo;t it? :) ). In other words, we are speaking of a
standard firewall/NAT router.&lt;/p&gt;
&lt;p&gt;Now, how can you access port 12345 on host behind the firewall given that this
port is not &amp;ldquo;exported&amp;rdquo; by the NAT on the firewall? This is quite simple. Open a
terminal window on your local computer and type the following:&lt;/p&gt;
&lt;pre class="highlight" data-user="user"&gt;&lt;code class="language-shell"&gt;[user@localhost ~] ssh -L12345:192.168.1.2:12345 joe@firewall.domain.tld&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From now on, as long as your SSH session is up and running you will be able to
reach &lt;code&gt;192.168.1.2:12345&lt;/code&gt; by connecting to &lt;code&gt;localhost:12345&lt;/code&gt; (i.e. the &lt;code&gt;12345&lt;/code&gt;
port on your local computer). Indeed, for this to work you need SSH access
anywhere inside the protected network (not necessarily on the firewall itself)
and if the firewall blocks any SSH access, you are out of luck.&lt;/p&gt;
&lt;h2 id="dynamic-port-forwarding"&gt;Dynamic port-forwarding&lt;/h2&gt;
&lt;p&gt;There are at least two usage patterns where I find SSH&amp;rsquo;s ability to forward
requests to many ports useful:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I need to connect to different services (possibly on different hosts) inside
  the protected network (as per the configuration described above) and I don&amp;rsquo;t
  want to specify all of them on the command line;&lt;/li&gt;
&lt;li&gt;I need to access some resource which is Geo-protected (e.g. allows access
  from a particular part of the world), e.g. want to watch US Netflix being
  physically in Australia&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In both cases, you use the following SSH command in your terminal window:&lt;/p&gt;
&lt;pre class="highlight" data-user="user"&gt;&lt;code class="language-shell"&gt;[user@localhost ~]$ ssh -D3128 joe@relay.domain.tld&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As long as you SSH session is active, you can use port &lt;code&gt;3128&lt;/code&gt; on your local
machine as SOCKS4/SOCKS5 proxy (e.g. you can configure proxy settings in your
browser to use &lt;code&gt;localhost:3128&lt;/code&gt;) and browse the Net through your SSH connection,
and all your requests will look like they are coming from &lt;code&gt;relay.domain.tld&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are many uses for this: for example, some payment processors won&amp;rsquo;t allow
you to pay for goods if you are trying to pay through them from some countries
even if you are a legitimate user, another use case is when you are concerned
re: your privacy &amp;ndash; you can conceal your actual location by building a chain of
SSH tunnels and access the desired web site through this chain :) .&lt;/p&gt;
&lt;h2 id="reverse-firewall-piercing"&gt;Reverse firewall piercing&lt;/h2&gt;
&lt;p&gt;Finally, what if you are behind a very strict firewall that limits almost
everything, but you need to provide some services to the outside world from
your computer (e.g. sharing your access to company&amp;rsquo;s confidential information
to folks from WikiLeaks&amp;hellip; just kidding :) )?&lt;/p&gt;
&lt;p&gt;To achieve this you need to have an SSH account somewhere in the Net &amp;ndash; just
Google for &amp;ldquo;free ssh account&amp;rdquo; and you will surely find one for yourself).&lt;/p&gt;
&lt;p&gt;Now, when you have the account, you can execute the following on your local
computer (which is inside that highly secure network :) ):&lt;/p&gt;
&lt;pre class="highlight" data-user="user"&gt;&lt;code class="language-shell"&gt;[user@localhost ~]$ ssh -R:60000:127.0.0.1:22 joe@friendly.domain.tld&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above command will setup such a configuration that connecting on port &lt;code&gt;60000&lt;/code&gt;
at &lt;code&gt;friendly.domain.tld&lt;/code&gt; will forward traffic to your local machine&amp;rsquo;s port 22
(which is behind a firewall) &amp;ndash; this will work as long as your SSH session to
the &lt;code&gt;friendly.domain.tld&lt;/code&gt; is active.  Unfortunately, there are several pitfalls
in this approach, but they are all resolvable.&lt;/p&gt;
&lt;p&gt;Firstly, you need to ensure that &lt;code&gt;friendly.domain.tld&lt;/code&gt; is using a recent version
of SSH daemon, otherwise you will be limited to bind only to the loopback
interface on the remote host.&lt;/p&gt;
&lt;p&gt;Secondly, even if they are using a recent version of the SSH daemon, they can
disallow such binding (e.g. setting &amp;ldquo;GatewayPorts no&amp;rdquo; in &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;),
and, again, you will be restricted to the loopback interface only.&lt;/p&gt;
&lt;p&gt;Finally, you need to find such a friendly host which allows you to connect to
the bound ports from the outside (many public ones have a firewall rule
preventing such access in order to prevent abuses of their services).&lt;/p&gt;
&lt;p&gt;All in all, the best option to try this is to have your own host somewhere (e.g.
purchase a small virtual environment from some hosting provider or create an
instance on AWS EC2), then you will be able to configure the remote side the
way you want it!&lt;/p&gt;
&lt;p&gt;Anyway, even if you fail to find a host that allows you to expose your service
to the public, you still should be able to access it yourself &amp;ndash; using the
forward firewall piercing technique described at the beginning of this post:&lt;/p&gt;
&lt;pre class="highlight" data-user="user" data-prompt=""[user@localhost"&gt;&lt;code class="language-shell"&gt;# from your home computer
[user@localhost ~]$ ssh -L60000:127.0.0.1:60000 joe@friendly.domain.tld&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once it is done your computer in the highly secure network should be reachable
via SSH on your &lt;code&gt;localhost:60000&lt;/code&gt;, e.g.&lt;/p&gt;
&lt;pre class="highlight" data-user="user"&gt;&lt;code class="language-shell"&gt;[user@localhost ~] ssh -p6000 my_account@localhost&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &lt;code&gt;my_account&lt;/code&gt; is a user allowed to SSH into your computer in the highly
secure network.&lt;/p&gt;</content><category term="ssh"></category></entry><entry><title>SSH port-forwarding (Basic)</title><link href="https://dmitry.khlebnikov.net/2010/11/29/ssh-port-forwarding-basic/" rel="alternate"></link><published>2010-11-29T10:00:00+11:00</published><updated>2020-05-17T04:45:11+10:00</updated><author><name>(GalaxyMaster)</name></author><id>tag:dmitry.khlebnikov.net,2010-11-29:/2010/11/29/ssh-port-forwarding-basic/</id><summary type="html">&lt;p&gt;I think all of you are using SSH in your daily routines. However, do you use
its full potential? Today&amp;rsquo;s topic is the SSH port-forwarding feature and how
it can be use to achieve some interesting configurations.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m sure most of you are aware of the feature, but how many of you are using
it? Personally, I&amp;rsquo;m a bit obsessed with it and have found numerous cases where
this feature of SSH is a real life saver.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s start with simple things and imagine that you have a server where you
are running MySQL (as a &lt;span class="truncated"&gt;&lt;/span&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;I think all of you are using SSH in your daily routines. However, do you use
its full potential? Today&amp;rsquo;s topic is the SSH port-forwarding feature and how
it can be use to achieve some interesting configurations.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m sure most of you are aware of the feature, but how many of you are using
it? Personally, I&amp;rsquo;m a bit obsessed with it and have found numerous cases where
this feature of SSH is a real life saver.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s start with simple things and imagine that you have a server where you
are running MySQL (as a backend for your website) and that you are not
comfortable to work with MySQL neither through the MySQL command line interface
nor through a web-interace like phpMyAdmin. Instead you prefer to use, say,
MySQL WorkBench or something similar running on your local computer.&lt;/p&gt;
&lt;p&gt;How one could do this? Well, I&amp;rsquo;ve seen a lot that people tend to configure the
MySQL server to listen on a public interface (i.e. an interface that is
reachable from the Internet), then access it from their computer directly.
It&amp;rsquo;s not that bad if you have a static &lt;abbr title="Internet Protocol"&gt;IP&lt;/abbr&gt; assigned to your computer and you
added a firewall rule protecting the MySQL port on the server to be reachable
from your &lt;abbr title="Internet Protocol"&gt;IP&lt;/abbr&gt; address only, but what if you are behind some kind of NAT and the
same &lt;abbr title="Internet Protocol"&gt;IP&lt;/abbr&gt; address is shared among others in your network? What if you don&amp;rsquo;t have
a static &lt;abbr title="Internet Protocol"&gt;IP&lt;/abbr&gt; and the dynamic &lt;abbr title="Internet Protocol"&gt;IP&lt;/abbr&gt; range assigned by your ISP is too broad?
Overall, I personally don&amp;rsquo;t like running MySQL on a public interface since
there were publicly known security vulnerabilities in the MySQL binary
protocol, and I can assure you there will be more discovered over the time.&lt;/p&gt;
&lt;p&gt;So, what should we do to access our remote database securely and conveniently?
Run the MySQL server on 127.0.0.1:3306 (well, if your web server is located on
another machine, you may want to bind MySQL to some internal interface &amp;ndash; the
network that links your servers only, e.g. 192.168.1.1:3306), and then use the
SSH port-forwarding feature to setup a tunnel between your remote database and
your local computer:&lt;/p&gt;
&lt;pre class="highlight" data-user="root"&gt;&lt;code class="language-shell"&gt;[root@localhost ~]# ssh -L3306:127.0.0.1:3306 user@server&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, &lt;code&gt;-L3306:127.0.0.1:3306&lt;/code&gt; says that we want &lt;code&gt;127.0.0.1:3306&lt;/code&gt; to be &amp;ldquo;mapped&amp;rdquo;
to our local host to port &lt;code&gt;3306&lt;/code&gt;. While the SSH session is active any packet
sent to &lt;code&gt;localhost:3306&lt;/code&gt; (on your computer) will be forwarded over the SSH
encrypted channel to the remote server and then will be fed to remote&amp;rsquo;s
&lt;code&gt;127.0.0.1:3306&lt;/code&gt;.  This means that as long as your SSH session is alive you
will be able to work with the remote MySQL server like it&amp;rsquo;s running on your
local computer and you can use any MySQL tools locally.&lt;/p&gt;
&lt;p&gt;Well, the above command was given for Linux, Mac OSX, and other Unix-based
systems. For Windows, you can use PuTTY to achive the same. I found the
following &lt;a href="https://www.akadia.com/services/ssh_putty.html"&gt;instructions for PuTTY&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;OK, this is not a new topic and it was described many times here and there on
the Internet, but I decided to write this article as a foundation for my
further articles on this topic which will cover more advanced usage of the SSH
port-forwarding feature. For example, I intend to document a configuration of
the MySQL replication setup between two servers located at two different data
centres where each server is a part of a server farm protected by a firewall.&lt;/p&gt;</content><category term="ssh"></category><category term="ssh"></category><category term="console"></category><category term="bastion"></category></entry></feed>