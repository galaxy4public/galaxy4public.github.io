<!DOCTYPE HTML>
<html lang="en">
	<head>
		<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://www.googletagmanager.com/gtag/js 'sha256-TelA7VsuYAMqhOKGk7CHgJyuqSJdmqZEp+hn6PWVRwQ=' https://www.google-analytics.com/analytics.js ; img-src 'self' https://www.google-analytics.com/r/collect https://www.google-analytics.com/collect https://stats.g.doubleclick.net/r/collect https://www.google.com/ads/ga-audiences https://www.google.com.au/ads/ga-audiences ; style-src 'self' 'sha256-fszvBX/J9dhPxFSJ5wUrq/Pvg6HrnTkWyshMZpaxSQY='; connect-src  https://www.google-analytics.com/j/collect https://stats.g.doubleclick.net/j/collect ; " />
		<title>Mind Drops</title>
		<script src="/theme/js/persistence.js" defer></script>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="theme-color" content="#535353" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="format-detection" content="telephone=no" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="apple-mobile-web-app-title" content="Mind Drops" />
		<meta name="description" content="">
		<link rel="apple-touch-icon" href="/theme/images/icons/mind-drops-192x192.png" />
		<link rel="manifest" type="text/json" href="/manifest.json" />
		<link rel="alternate" type="application/atom+xml" href="https://dmitry.khlebnikov.net/feeds/all.atom.xml" title="Mind Drops Full Atom Feed" />
		<link rel="alternate" type="application/atom+xml" href="https://dmitry.khlebnikov.net/feeds/ssh.atom.xml" title="Mind Drops Categories Atom Feed" />
		<link rel="preload" as="style" href="/theme/css/reset.css" />
		<link rel="preload" as="style" href="/theme/css/fonts/Icons.css" />
		<link rel="preload" as="style" href="/theme/css/fonts/Exo2.css" />
		<link rel="preload" as="style" href="/theme/css/fonts/Oswald.css" />
		<link rel="preload" as="style" href="/theme/css/fonts/DancingScript.css" />
		<link rel="preload" as="style" href="/theme/css/fonts/FiraCode.css" />
		<link rel="preload" as="style" href="/theme/css/base.css" />
		<link rel="preload" as="script" href="/theme/js/persistence.js" />
		<link rel="preload" as="script" href="/theme/js/visited.js" />
		<link rel="preload" as="script" href="/theme/js/service.js" />
		<script src="/theme/js/loader.js" defer></script>
		<link rel="icon" type="image/png" href="/images/galaxy.png" />

		<link rel="stylesheet" type="text/css" href="/theme/css/article.css" />
		<meta name="tags" content="console" />
		<meta name="tags" content="ssh" />
		<meta name="tags" content="howto" />
	</head>
	<body>

		<input type="radio" name="menu-toggle" id="menu-toggle-full" value="full" tabindex="0" checked />
		<input type="radio" name="menu-toggle" id="menu-toggle-mini" value="mini" tabindex="1" />
		<input type="radio" name="menu-toggle" id="menu-toggle-hide" value="hide" tabindex="2" />
		<label for="menu-toggle-full" class="icon menu">Show the full menu panel on the screen</label>
		<aside id="sidebar">
			<label for="menu-toggle-mini" class="icon left-big">Show the minimised menu panel on the screen</label>
			<label for="menu-toggle-hide" class="icon eye-off">Remove the menu panel off the screen</label>
			<div id="logo" class="box shadow">
				<picture>
					<source srcset="/images/galaxy.png.webp" type="image/webp">
					<img src="/images/galaxy.png" alt="Logo">
				</picture>
			</div>

			<!-- Search -->
			<section class="box search">
				<form name="google search" class="icon search" method="get" action="/search">
					<label for="search" class="offscreen">Search</label>
					<input id="search" type="text" class="text" name="q" placeholder="Search" />
				</form>
			</section>

			<nav>
				<ul>
					<li>
						<a class="icon home" href="/">Home</a>
					</li>
					<li>
						<a class="icon user" href="/about">About</a>
					</li>
					<li>
						<a class="icon phone" href="/contact">Contact</a>
					</li>
				</ul>
			</nav>

			<!-- Text -->
			<section class="box text-style1">
				<div class="inner">
					<p>
						<strong>Mind Drops:</strong>: A place to unload all these assorted bits.
					</p>
				</div>
			</section>

			<!-- Copyright -->
			<ul id="copyright">
				<li>&copy; Openwall Pty Ltd 2020 </li>
				<li><a href="/legal/terms-of-service">Terms of Service</a></li>
			</ul>
		</aside>

		<!-- Content -->
		<div id="content">
			<div class="inner">
				<article id="transparent-ssh-host-jumping-advanced" class="box post">
					<header>
						<h1><a name="top">Transparent SSH host-jumping (Advanced)</a></h1>
					</header>
					<div class="info">
						<span class="date"><span class="day">06</span> <span class="month">Aug<span>ust</span></span> <span class="year">2015</span></span>
						<ul class="stats">
							<li><a href="#" class="icon fa-comment">?</a></li>
							<li><a href="#" class="icon fa-heart">?</a></li>
							<li><a href="#" class="icon fa-twitter">?</a></li>
							<li><a href="#" class="icon fa-facebook">?</a></li>
						</ul>
					</div>
					<p>In this brief article I am going to describe how I resolved a nagging issue I
had with setting up access to hosts which are not directly reachable, but where
you need to forward your connection through an intermediate host.</p>
<p><a href="https://dmitry.khlebnikov.net/2010/12/10/ssh-port-forwarding-intermediate/">Previously</a>, I was using the local SSH port-forwarding technique (although I
was configuring hosts I connect to in the <code>~/.ssh/config</code> file instead of
using the command-line options). However, this approach turned out to be quite
inconvenient since every time I wanted to connect to a new host (and, possibly,
through a new intermediate host) I had to edit my SSH configuration file and
add something like the following:</p>
<pre class="highlight"><code class="language-ssh_config">Host intermediate
    HostName 192.168.1.1
    HostKeyAlias intermediate
    LocalForward 10001 target:22

Host target
    HostName 127.0.0.1
    HostKeyAlias target
    Port 10001</code></pre>


<p>Upon closer examination of my day-to-day routine I found two things that
frustrated me the most:</p>
<ol>
<li>My <code>~/.ssh/config</code> file was growing uncontrollably and became hard to
     navigate;</li>
<li>Each time I needed to connect to the target host through the intermediate
     host I had to open two sessions with one of them being idle most of the
     time.</li>
</ol>
<p>After a while I stumbled upon an article describing quite a generic way to
tunnel through an intermediate host and found the approach quite convenient for
the day-to-day use. So, I have added the following block into my <code>~/.ssh/config</code>
file just before the <code>Host *</code> section:</p>
<pre class="highlight"><code class="language-ssh_config">Host */*
    ProxyCommand ssh $(dirname %h) -W $(basename %h):%p</code></pre>


<p>From that point on, I could connect to a target host via an intermediate one
by simply executing the following command:</p>
<pre class="highlight"><code class="language-shell">ssh user@intemediate/target</code></pre>


<p>The configuration with the <code>ProxyCommand</code> directive was spawning two <code>ssh</code>
processes with one connected to the intermediate host in the background and the
other proxied through the intermediate host and connected to the target running
in the foreground, so from my point of view I had just one terminal session
open. The configuration allowed to chain as many hosts as I wanted, e.g.:</p>
<pre class="highlight"><code class="language-shell">ssh user@hostA/hostB/hostC/hostD</code></pre>


<p>The above would result in three <code>ssh</code> processes running in the background (the
first connected to hostA, the second connected to <em>hostB</em> proxied through <em>hostA</em>,
and the third connected to <em>hostC</em> proxied through <em>hostB</em>) and one foreground
process which was connected to <em>hostD</em> proxied via <em>hostC</em>. This is great and quite
flexible to use, however, this approach has a number of limitations:</p>
<ul>
<li>you cannot specify different ports for different hosts in a chain;</li>
<li>neither can you use different login names for different hosts in the chain;</li>
<li>establishing connection to different chains sharing a part of the chain
    would not reuse already established connections, i.e. slow connection times.</li>
</ul>
<p>Personally, I am using the same login name and the same ports on hosts I am
accessing, so the first two items were not an issue for me, but the last one
was irritating enough and I decided to figure out whether it is possible to
optimise it. After a bit of reading the documentation and a few attempts I came
up with the following configuration block in my <code>~/.ssh/config</code> file (remember,
this block should be placed <em>before</em> the <code>Host *</code> one):</p>
<pre class="highlight"><code class="language-ssh_config">Host */*
    ControlMaster auto
    ControlPath   ~/.ssh/.sessions/%r@%h:%p
    ProxyCommand /bin/sh -c 'mkdir -p -m700 ~/.ssh/.sessions/&quot;%r@$(dirname %h)&quot; &amp;&amp; exec ssh -o &quot;ControlMaster auto&quot; -o &quot;ControlPath   ~/.ssh/.sessions/%r@$(dirname %h):%p&quot; -o &quot;ControlPersist 120s&quot; -l %r -p %p $(dirname %h) -W $(basename %h):%p'</code></pre>


<p>Let&rsquo;s review it line by line, so the logic is clear:</p>
<pre class="highlight"><code class="language-ssh_config">Host */*</code></pre>


<p>This host definition block would catch any host specified on the <code>ssh</code> command
line when the host name matches the <code>*/*</code> pattern, so <code>ssh hostA/hostB/hostC</code>
will be matched as <code>hostA/hostB</code> being the first part before <code>/</code> and <code>hostC</code> as
the second part after <code>/</code>. Due to a recursive call to <code>ssh</code> (see below) this
block will be recursively applied to all hosts in the specified chain.</p>
<pre class="highlight"><code class="language-ssh_config">    ControlMaster auto</code></pre>


<p>This directive instructs <code>ssh</code> to try to reuse an existing control channel to
communicate with the remote host, and if such a channel does not exist it will
be created, so further connections to the same remote host would benefit from
a speedup provided by the already established connection.</p>
<pre class="highlight"><code class="language-ssh_config">    ControlPath ~/.ssh/.sessions/%r@%h:%p</code></pre>


<p>This directive provides <code>ssh</code> with the location of the control channel socket
file. The socket file should be unique for each remote host. Since we are
reusing the existing connection and skipping the authentication the socket file
should be tagged with the corresponding login name, this is why we are using %r
(remote login name), %h (the remote host name), and %p (the remote port) as
part of the file name. Please note that due to our usage of &ldquo;/&rdquo; as a host
separator in the chain the path constructed here will have a subdirectory
defined in the middle of the %h expansion. <code>ssh</code> would not automatically create
that subdirectory, so it is something we need to address (see below)</p>
<pre class="highlight"><code class="language-ssh_config">    ProxyCommand …</code></pre>


<p>This is the heart of the whole block. I am starting this proxy command with
<code>/bin/sh -c '…'</code> since <code>ssh</code> is <code>exec()</code>uting the specified command (this
replaces the spawned shell and makes it impossible to conditionally chain
commands), therefore I am using the shell binary as the proxy command to get
the ability to script my logic. Then I am creating the required directory
structure for the control channels under <code>~/.ssh/.sessions</code> (note the <code>-p</code>
argument to <code>mkdir</code>, this will create all the missing parts of the specified
tree, but also would silence <code>mkdir</code> in case all of the directories already
exist). It is worth to mention that with this <code>mkdir</code> command I am creating the
subdirectory for the <code>ControlPath</code> defined for the enclosing <code>Host */*</code> block.</p>
<p>The second part of the command line is conditionally executing <code>ssh</code> if <code>mkdir</code>
did not report any issues. It is good to execute <code>ssh</code> here since we do not
need a redundant shell hanging around in the process tree. In this recursive
<code>ssh</code> call we explicitly specify that we also need multiplexing of the control
channels created by the parent connections (they are &ldquo;parent&rdquo; since this is the
connection that established first and which enables access to the hosts further
down the specified chain) as well as we explicitly specify the location of the
control channel (note that since it is a parrent connection we are stripping
the rest of host names from the <code>%h</code> macro using <code>dirname</code>.</p>
<p>Finally, the third explicitly specified directive is <code>ControlPersist</code> which is
set to <code>120s</code>. This directive instructs <code>ssh</code> to stay in the background and
maintain the control channel in case we decide to reuse it, but if no activity
on the control channel is detected for 2 minutes the <code>ssh</code> process would
terminate. Without this directive the moment you close the connection which was
the master connection all dependent connections would also be closed, e.g. if
you have two sessions: one to <code>hostA/hostB</code> and the other to <code>hostA/hostC</code>, the
moment you closed the first connection the second one will be immediately
terminated if you do not have the <code>ControlPersist</code> configured.</p>
<p>The rest of the <code>ssh</code> arguments is obvious: we connect to the first host in the
provided host chain (we are extracting that part with <code>dirname %h</code>) and we are
proxying stdin/stdout to the last host in the supplied chain with the <code>-W</code>
option.</p>
<p>Basically, the control flow when you do <code>ssh user@hostA/hostB/hostC</code> is the
following:</p>
<ol>
<li>
<p><code>ssh</code> matches the <code>*/*</code> pattern against the provided host name
     (<code>hostA/hostB/hostC</code>)</p>
</li>
<li>
<p><code>ssh</code> tries to reuse the control channel by attempting to open the
     <code>~/.ssh/.sessions/user@hostA/hostB/hostC:22</code> socket, if successful the
     connection is established and the command prompt is displayed to the
     calling user, otherwise the execution continues</p>
</li>
<li>
<p><code>ssh</code> executes the defined <code>ProxyCommand</code> command</p>
</li>
<li>
<p>the first part of the command creates <code>~/.ssh/.sessions/hostA/hostB</code> if it
     is not there</p>
</li>
<li>
<p>the second part executes</p>
<pre class="highlight"><code class="language-shell">ssh … -o &quot;ControlPath ~/.ssh/.sessions/user@hostA/hostB:22&quot; … hostA/hostB -W hostC:22</code></pre>


<p>This will initiate another round of the above steps, but with a shorter chain
 and it will be recursive until there is just a single host left, e.g. when
 we ascend to <code>hostA</code> as the host to connect to.</p>
</li>
<li>
<p>now, with connected stdin/stdout to port 22 on <code>hostC</code> (in the last
     iteration) <code>ssh</code> performs the authentication against <code>hostC</code></p>
</li>
<li>
<p>if authentication is successful <code>ssh</code> creates the
     <code>~/.ssh/.sessions/user@hostA/hostB/hostC:22</code> control channel socket and
     becomes the master of that control channel</p>
</li>
<li>
<p>a command prompt is displayed to the calling user</p>
</li>
</ol>
<p>I hope this little trick will save you some time and will make your life
easier. :)</p>
					<ul class="tags">
						<li class="tag">
							<div>
								<a href="/tag/console/" class="tag name">console</a>
							</div>
							<a href="/tag/console/" class="tag count">7</a>
						</li>
						<li class="tag">
							<div>
								<a href="/tag/ssh/" class="tag name">ssh</a>
							</div>
							<a href="/tag/ssh/" class="tag count">4</a>
						</li>
						<li class="tag">
							<div>
								<a href="/tag/howto/" class="tag name">howto</a>
							</div>
							<a href="/tag/howto/" class="tag count">4</a>
						</li>
					</ul>
					<footer>
						Offloaded on
						<time datetime="2015-08-06 10:00:00+10:00">Thu, 06/08/2015 at 10:00 (<a href="https://time.is/AEST" target="_blank">AEST</a>)</time>
						<span class="category-tag"><a href="/category/ssh">ssh</a></span>
					</footer>				</article>
			</div>
		</div>
		<script async src="https://www.googletagmanager.com/gtag/js?id=UA-165060547-1"></script>
		<script>
			window.dataLayer = window.dataLayer || [];
			function gtag(){dataLayer.push(arguments);}
			gtag('js', new Date());
			gtag('config', 'UA-165060547-1');
		</script>
	</body>
</html>